#' SIRbound_R estimates the SIR model when only R is observed.
#' @param ts Event time
#' @param R Number of recovered individuals
#' @param n Total number of individuals
#' @param I0 Number of infected individual at time 0
#' @param It Number of infected indiviudal at time Tmax
#' @param alpha Level for confidence intervals
#' @return
#' \item{betahat}{partial identified region for \eqn{\beta}}
#' \item{gammahat}{partial identified region for \eqn{\gamma}}
#' \item{betahat_CI}{Confidence interval for \eqn{\beta}}
#' \item{gammahat_CI}{Confidence interval for \eqn{\gamma}}
#' \item{IU}{Estimated upper bound for I}
#' \item{IL}{Estimated lower bound for I}
#' @author Forrest Crawford and Sida Peng
#' @export
#'



SIRbound_R <- function(ts,R,n,I0,It,alpha) {

  k    = length(ts)
  d    = diff(ts)
  IL   = rep(NA,k)
  IU   = rep(NA,k)
  SIU  = rep(NA,k)
  SIL  = rep(NA,k)
  SIL1 = rep(NA,k)
  SIL2 = rep(NA,k)

  #consturct upper bound for S*I
  c0   = floor((n -R[1])/2)
  ct   = floor((n -R[k])/2)
  stepcount = R[k] - R[1]
  if (I0<=c0 & It>=ct){
    for (j in 1:k){
      SIU[j] = floor((n -R[j])/2)*ceiling((n -R[j])/2)
    }
  }else if (I0<=c0 & It<ct & It>=(ct-stepcount/2)) {
    t_s = max(which(R <= R[k] - 2*ct + 2*It))
    for (j in 1:t_s){
      SIU[j] = floor((n -R[j])/2)*ceiling((n -R[j])/2)
    }
    for (j in (t_s+1):k){
      SIU[j] = (floor((n -R[j])/2)-R[j]+R[t_s])*(n-floor((n -R[j])/2)-R[t_s])
    }
  }else if (I0<=c0 &  It<(ct-stepcount/2)) {
    for (j in 1:k){
      SIU[j] = (It+R[k]-R[j])*(n-It-R[k])
    }
  }else if (I0>(c0+stepcount/2)) {
    for (j in 1:k){
      SIU[j] = (I0+R[1]-R[j])*(n-I0-R[1])
    }
  }else if (I0<=(c0+stepcount/2) & I0>c0 & It>=ct ) {
    t_s = min(which(R >= R[1] - 2*c0 + 2*I0))
    for (j in 1:t_s){
      SIU[j] = (I0+R[1]-R[j])*(n-I0-R[1])
    }
    for (j in (t_s+1):k){
      SIU[j] = floor((n -R[j])/2)*ceiling((n -R[j])/2)
    }
  }else if (I0<=(c0+stepcount/2) & I0>c0 & It<ct ) {
    t_s1 = min(which(R >= R[1] - 2*c0 + 2*I0))
    t_s2 = max(which(R <= R[k] - 2*ct + 2*It))
    print(R[k])
    for (j in 1:t_s1){
      SIU[j] = (I0+R[1]-R[j])*(n-I0-R[1])
    }
    for (j in (t_s1+1):t_s2){
      SIU[j] = floor((n -R[j])/2)*ceiling((n -R[j])/2)
    }
    for (j in (t_s2+1):k){
      SIU[j] = (floor((n -R[j])/2)-R[j]+R[t_s2])*(n-floor((n -R[j])/2)-R[t_s2])
    }
  }

  # construct lower boudn for S*I as a corner solution
  for (j in 1:k){
    SIL1[j] = (It + R[k] - R[j])*(n-It-R[k])
    if (R[j] != R[k]){
      SIL2[j] = max(1,(I0 + R[1] - R[j]))*min(n-R[j]-1, n-I0-R[1])
    }else{
      SIL2[j] = 0
    }
  }
  S1 = d %*% SIL1[1:(k-1)]
  S2 = d %*% SIL2[1:(k-1)]
  if (S1<S2){
    SIL = SIL1
  }else{
    SIL = SIL2
  }

  IU[1] = (It + R[k] - R[1])
  IL[1] = I0
  for (j in 2:k){
    if (R[j]>R[j-1]){
      IU[j] = IU[j-1]-(R[j]-R[j-1])
    }else{
      IU[j] = IU[j-1]
    }
      if (R[j] != R[k]){
        IL[j] = max(1,IL[j-1]-(R[j]-R[j-1]))
      }else{
        IL[j] = 0
      }

  }

  # consturct identified region for beta and gamma
  betahat_U = (R[k]-I0+It) / ( d %*% SIL[1:(k-1)])
  betahat_L = (R[k]-I0+It) / ( d %*% SIU[1:(k-1)])
  gammahat_U = (R[k]-R[1]) / ( d %*% IL[1:(k-1)])
  gammahat_L = (R[k]-R[1]) / ( d %*% IU[1:(k-1)])

  #calculate standard error
  sigma_b_u = sqrt(betahat_U^2/(R[k]-I0+It))
  sigma_b_l = sqrt(betahat_L^2/(R[k]-I0+It))
  sigma_r_u = sqrt(gammahat_U^2/(R[k]-R[1]))
  sigma_r_l = sqrt(gammahat_L^2/(R[k]-R[1]))

  #construct confidence region
  betahat_CI = SIRci(betahat_U, betahat_L, sigma_b_u, sigma_b_l, alpha, n)
  gammahat_CI = SIRci(gammahat_U, gammahat_L, sigma_r_u, sigma_r_l, alpha, n)

  output =list(betahat = c(betahat_L,betahat_U),
               gammahat = c(gammahat_L, gammahat_U),
               betahat_CI = betahat_CI,
               gammahat_CI = gammahat_CI,
               IL = IL,
               IU = IU)
  return(output)
}



